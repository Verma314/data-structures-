1) 

https://www.quora.com/How-do-I-strengthen-my-knowledge-of-data-structures-and-algorithms/answer/Robert-Love-1?srid=RuUP

By Robert Love (Google)
 
I  see it time and again in Google interviews or new-grad hires: 
The way data structures and algorithms—among the most important subjects in a proper computer science curriculum—are learnt 
is often insufficient. 
 
That's not to say students read the wrong books (see my recommendation below) 
or professors teach the wrong material, 
but how students ultimately come to understand the subject is lacking.

The key to a solid foundation in data structures and algorithms is not
an exhaustive survey of every conceivable data structure and its subforms, 
with memorization of each's Big-O value and amortized cost. 
Such knowledge is great and impressive if you've got it, but you will rarely need it. 

For better or worse, your career will likely never require you to implement a red-black tree node removal algorithm.
But you ought be able—with complete ease!—to identify when a binary search tree is a useful solution to a problem, 
because you will often need that skill.

So stop trying to memorize everything. Instead, start with the basics and learn to do two things:

*)  Visualize the data structure. 
    Intuitively understand what the data structure looks like, what it feels like to use it, 
    and how it is structured both in the abstract and physically in your computer's memory. 
    This is the single most important thing you can do, 
    and it is useful from the simplest queues and stacks up through the most complicated self-balancing tree. 
    Draw it, visualize it in your head, whatever you need to do: Understand the structure intuitively.
    
*)  Learn when and how to use different data structures and their algorithms in your own code. 
    This is harder as a student, as the problem assignments you'll work through just won't impart this knowledge. 
    That's fine. Realize you won't master data structures until you are working on a real-world problem 
    and discover that a hash is the solution to your performance woes. 
    
    But even as a student you should focus on learning not the minutia details but the practicalities: 
    When do you want a hash? When do you want a tree? When is a min-heap the right solution?

One of the questions I ask in Google engineering interviews has a binary search tree as a potential solution (among others). 
Good candidates can arrive at the binary search tree as the right path in a few minutes, 
and then take 10-15 minutes working through the rest of the problem and the other roadblocks I toss out. 
But occasionally I get a candidate who intuitively understands trees and can visualize the problem I'm presenting. 
They might stumble on the exact algorithmic complexity of some operation, 
but they can respond to roadblocks without pause because they can visualize the tree. They get it.


As for a book, there is but one: Introduction to Algorithms 
by Cormen, Leiserson, Rivest, and Stein, otherwise known as CLRS.

If you want another text, perhaps one with more examples in a specific language, 
I recommend Robert Sedgewick's Algorithms in C++ or Algorithms in Java, as appropriate. 
I prefer CLRS as a text, but you might find these a better teaching aid.
